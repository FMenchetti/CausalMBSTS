library(CausalMBSTS)
y <- cbind(rnorm(100), rnorm(100, 2, 3))
X <- cbind(rnorm(100, 0.5, 1) + 5, rnorm(100, 0.2, 2) - 2)
model.2 <- SSModel(y ~ SSMtrend(degree = 1, Q = matrix(NA,2,2)) + SSMseasonal(period=7, Q = matrix(NA,2,2)))
library(CausalMBSTS)
model.2 <- SSModel(y ~ SSMtrend(degree = 1, Q = matrix(NA,2,2)) + SSMseasonal(period=7, Q = matrix(NA,2,2)))
library(KFAS)
model.2 <- SSModel(y ~ SSMtrend(degree = 1, Q = matrix(NA,2,2)) + SSMseasonal(period=7, Q = matrix(NA,2,2)))
library(CausalMBSTS)
y <- cbind(rnorm(100), rnorm(100, 2, 3))
X <- cbind(rnorm(100, 0.5, 1) + 5, rnorm(100, 0.2, 2) - 2)
dates <- seq(as.Date('2020-01-10'),as.Date('2020-01-10')+99, 1)
int.date <- as.Date('2020-04-01')
y[dates >= int.date, ] <- y[dates >= int.date, ]+2
model <- SSModel(y ~ SSMtrend(degree = 1, Q = matrix(NA,2,2)) + SSMseasonal(period=4, Q = matrix(NA,2,2)))
causal <- causal.mbsts(model, X = X, y = y, dates = dates, int.date = int.date, s0.eps = diag(2), s0.k = diag(2), niter = 100, burn = 10)
library(CausalMBSTS)
library(CausalMBSTS)
library(CausalMBSTS)
library(CausalMBSTS)
library(CausalMBSTS)
library(CausalMBSTS)
library(CausalMBSTS)
library(CausalMBSTS)
library("CausalImpact", lib.loc="~/R/win-library/3.6")
detach("package:CausalImpact", unload=TRUE)
library(CausalMBSTS)
library(CausalMBSTS)
path<-"C:/Users/fiamm/Documents/GitHub/CausalMBSTS/R"
tidy_dir(path=path, wrap=FALSE)
library(formatR)
tidy_dir(path=path, wrap=FALSE)
library(CausalMBSTS)
library(CausalMBSTS)
library(CausalMBSTS)
# Generating a panel of observations (d = 3) and a vector of dates
set.seed(1)
y <- cbind(seq(0.5,200,by=0.5)*0.1 + rnorm(400),
seq(100.25,200,by=0.25)*0.05 + rnorm(400),
seq(1,400,by=1)*(-0.01) + rnorm(400, 0, 0.5))
dates <- seq(as.Date('2019-01-10'),as.Date('2019-01-10')+399, 1)
# Adding a fictional intervention and four covariates (they should be related to the outcome but unaffected by the intervention). To illustrate the functioning of Bayesian model selection, one covariate is assumed to be unrelated to y.
int.date <- as.Date('2019-11-05')
y.new <- y; y.new[dates >= int.date, ] <- y.new[dates >= int.date, ]*1.3
x1 <- y[,1]*0.5 + y[,2]*0.3 + y[,3]*0.1
x2 <- y[,2]*0.1 + rnorm(dim(y)[1],0,0.5)
x3 <- y[,3]*1.2 + rnorm(dim(y)[1],0,0.5)
x4 <- rnorm(dim(y)[1], 5, 10)
X <- cbind(x1, x2, x3, x4)
# Some plots
par(mfrow=c(1,3))
for(i in 1:dim(y.new)[2]){
plot(y.new[,i], x = dates, type='l', col='cadetblue', xlab='', ylab='', main= bquote(Y[.(i)]))
lines(y[,i], x = dates, col='orange')
}
par(mfrow=c(1,4))
for(i in 1:dim(X)[2]){
plot(X[,i], type='l', col = 'darkgreen', x = dates, xlab='', ylab='', main = bquote(x[.(i)]))
}
# Model definition (local level + seasonal model)
model.1 <- SSModel(y ~ SSMtrend(degree = 1, Q = matrix(NA)) + SSMseasonal(period=7, Q = matrix(NA)))
causal.1 <- causal.mbsts(model.1, X = X, y = y.new, dates = dates, int.date = int.date, s0.k = 0.1*diag(3), s0.eps = 0.1*diag(3), niter = 100, burn = 10, horizon = c('2019-12-05','2020-02-13'))
causal.1$general.effect
par(mar = c(2,2,2,2))
par(mfrow=c(2,3))
plot(causal.1, int.date = int.date, type = c('impact', 'forecast'))
library(CausalMBSTS)
library(CausalMBSTS)
library(CausalMBSTS)
y <- cbind(rnorm(100), rnorm(100, 2, 3))
X <- cbind(rnorm(100, 0.5, 1) + 5, rnorm(100, 0.2, 2) - 2)
model.2 <- SSModel(y ~ SSMtrend(degree = 1, Q = matrix(NA,2,2)) + SSMseasonal(period=7, Q = matrix(NA,2,2)))
mcmc.2 <- mbsts.mcmc(model.2, X = X, s0.k = diag(2), s0.eps = diag(2), niter = 100, burn = 10)
newdata <- cbind(rnorm(30), rt(30, 2))
pred.2 <- predict(mcmc.2, newdata)
mbsts <- mcmc.2
t <- dim(mbsts$y)[1]  # number of time points
K <- dim(mbsts$R)[2]  # tot number of state disurbances
p <- dim(mbsts$y)[2]  # number of time series
k <- K/p  # number of state disturbances for each time series
M <- dim(mbsts$T)[1]  # tot number of states
M
states.new <- array(NA, c(step, M, niter))
states.new <- array(NA, c(step, M, 100))
states.new <- array(NA, c(dim(newdata)[1], M, 100))
dim(states.new)
colnames(states.new) <- colnames(mbsts$states.samples)
length(colnames(mbsts$states.samples))
predict.mbsts <- function(object, steps.ahead, newdata = NULL, ...) {
# Given an object of class 'mbsts' and the number of 'steps.ahead' in the future to be
# forecaste, this function provides in-sample forecasts and out-of-sample forecasts,
# both based on drawing from the posterior predictive distribution. If 'x' contains
# a regression component, then the new matrix of predictors 'newdata' must be provided.
# Note that NA values are not allowed in the new regressor matrix.
#
# Args:
#   object       : an object of class 'mbsts'
#   steps.ahead : an integer value specifying the number of steps ahead to be forecasted
#   newdata     : optional matrix of new data
#
# Value:
#   post.pred.0 : T x p x niter array of in-sample forecasts
#   post.pred.1 : S x p x niter array out-of-sample forecasts, where S is the number of
#                 forecasted periods (set to the length of provided new data)
#   post.pred   : (T + S) x p x niter array combining in- and out-of-sample forecasts
browser()
### Dimensionalities & other objects
mbsts <- object
# get dim
t <- dim(mbsts$y)[1]  # number of time points
K <- dim(mbsts$R)[2]  # tot number of state disurbances
p <- dim(mbsts$y)[2]  # number of time series
k <- K/p  # number of state disturbances for each time series
M <- dim(mbsts$T)[1]  # tot number of states
if (is.null(mbsts$X)) {
step <- steps.ahead
} else {
step <- dim(newdata)[1]
}  # number of obs to forecast
niter <- mbsts$niter - mbsts$burn  # number of simulations
last <- dim(mbsts$eta.samples)[1]  # last draw from the posterior p(alpha_t|Y_n)
### Empty arrays to store iterations
eta.new <- array(NA, c(step, K, niter))
states.new <- array(NA, c(step, M, niter))
colnames(states.new) <- colnames(mbsts$states.samples)
y.star <- array(NA, c(step, p, niter))
post.pred.0 <- array(NA, c(t, p, niter))  # storing in-sample draws
post.pred.1 <- array(NA, c(step, p, niter))  # storing out-of-samples draws
post.pred <- array(NA, c(t + step, p, niter))  # all together
for (i in 1:niter) {
### STEP 1: Get in-samples draws from the ppd.
# Details:  let theta = (alpha, beta, Sigma.eps, z, Sigma.eta),
#           during the MCMC we got samples from the joint posterior distribution p(theta|y). So
#           now we can draw new values y.tilde from the posterior predictive distribution by simply
#           taking the 'niter' draws from the joint p(theta|y) and substitute them into model equations
#           (we assume that y.new comes from the same distribution of y so that y.new is
#           independent of y given theta).
if (is.null(mbsts$X)) {
post.pred.0[, , i] <- tcrossprod(mbsts$states.samples[, , i], mbsts$Z[, , 1]) + mbsts$eps.samples[,
, i]
} else {
post.pred.0[, , i] <- tcrossprod(mbsts$states.samples[, , i], mbsts$Z[, , 1]) + mbsts$X %*%
mbsts$beta[, , i] + mbsts$eps.samples[, , i]
}
### STEP 2: Get new out-of-samples draws from the ppd.
# Details: this time an out-of sample draw y.new is no more independent
#          of past y given theta. To see that, let's say we want to sample y_t+k | Y_t.
#          This time, theta = (alpha_t+k,...,alpha_t+1, alpha_t, beta, Sigma.eps, z, Sigma.eta)
#          and from our MCMC we have just the posterior of (alpha_t, beta, Sigma.eps, z, Sigma.eta)
#          because we sampled from the full conditional p(alpha_t | Y_t, beta, Sigma.eps, z, Sigma.eta).
#          Thus, to sample from y_t+k | y_t we should 'recover' the missing dependence structure
#          p(alpha_t+k,...,alpha_t+1 | theta') where theta' is our 'old' theta, that is
#          theta' = alpha_t, beta, Sigma.eps, z, Sigma.eta. More details in the pdf.
#          Conversely, y*_t+k =  y_t+k - Z alpha_t+k is independent of y*_t given theta',
#          because there's no more time component and we can just write y*.
#          During the MCMC we sampled from the joint posterior p(beta,Sigma.eps,z|y*),
#          and as in step 1 we can use those draws to sample from the
#          posterior predictive distribution y.new* | y* by simply taking the draws from
#          p(beta,Sigma.eps,z|y*) and then draw from p(y.new*|beta,Sigma.eps,z).
#
# 2.1. Sampling new states
eta.new <- matrix(mvrnorm(1, rep(0, K), mbsts$Sigma.eta[, , i]), nrow = K)
states.new[1, , i] <- mbsts$T[, , 1] %*% matrix(mbsts$states.samples[last, , i], M) + mbsts$R[,
, 1] %*% eta.new
ind <- if (step > 1) {
2:step
} else {
NULL
}
for (j in ind) {
eta.new <- matrix(mvrnorm(1, rep(0, K), mbsts$Sigma.eta[, , i]), nrow = K)
states.new[j, , i] <- mbsts$T[, , 1] %*% matrix(states.new[j - 1, , i], nrow = M) + mbsts$R[,
, 1] %*% eta.new
}
# 2.2. Sampling y*.new (note that in the simple case without covariates y*.new = eps)
if (is.null(mbsts$X)) {
y.star[, , i] <- mvrnorm(1, rep(0, p), mbsts$Sigma.eps[, , i])
} else {
y.star[, , i] <- newdata %*% mbsts$beta[, , i] + mvrnorm(1, rep(0, p), mbsts$Sigma.eps[,
, i])
}
# 2.3. Out-of-sample draws
post.pred.1[, , i] <- states.new[, , i] %*% t(mbsts$Z[, , 1]) + y.star[, , i]
### STEP 3: Combining in-sample and out-of-samples draws
post.pred[, , i] <- rbind(post.pred.0[, , i], post.pred.1[, , i])
}
return(list(post.pred.0 = post.pred.0, post.pred.1 = post.pred.1, post.pred = post.pred))
}
y <- cbind(rnorm(100), rnorm(100, 2, 3))
X <- cbind(rnorm(100, 0.5, 1) + 5, rnorm(100, 0.2, 2) - 2)
model.2 <- SSModel(y ~ SSMtrend(degree = 1, Q = matrix(NA,2,2)) + SSMseasonal(period=7, Q = matrix(NA,2,2)))
mcmc.2 <- mbsts.mcmc(model.2, X = X, s0.k = diag(2), s0.eps = diag(2), niter = 100, burn = 10)
newdata <- cbind(rnorm(30), rt(30, 2))
pred.2 <- predict(mcmc.2, newdata)
y <- cbind(rnorm(100), rnorm(100, 2, 3))
X <- cbind(rnorm(100, 0.5, 1) + 5, rnorm(100, 0.2, 2) - 2)
model.2 <- SSModel(y ~ SSMtrend(degree = 1, Q = matrix(NA,2,2)) + SSMseasonal(period=7, Q = matrix(NA,2,2)))
mcmc.2 <- mbsts.mcmc(model.2, X = X, s0.k = diag(2), s0.eps = diag(2), niter = 100, burn = 10)
newdata <- cbind(rnorm(30), rt(30, 2))
pred.2 <- predict(mcmc.2, newdata = newdata)
library(CausalMBSTS)
library(CausalMBSTS)
library(CausalMBSTS)
library(CausalMBSTS)
library(CausalMBSTS)
library(CausalMBSTS)
y <- cbind(seq(0.5,200,by=0.5)*0.1 + rnorm(400),
seq(100.25,200,by=0.25)*0.05 + rnorm(400),
rnorm(400, 5,1))
mbsts.1 <- as.mbsts(y = y, components = c(trend, seasonal), seas.period = 7, s0.r = diag(3), s0.eps = diag(3), niter = 100, burn = 10)
mbsts.1 <- as.mbsts(y = y, components = c("trend", "seasonal"), seas.period = 7, s0.r = diag(3), s0.eps = diag(3), niter = 100, burn = 10)
library(CausalMBSTS)
## Example 1 : local level + seasonal (d = 3)
y <- cbind(seq(0.5,200,by=0.5)*0.1 + rnorm(400),
seq(100.25,200,by=0.25)*0.05 + rnorm(400),
rnorm(400, 5,1))
mbsts.1 <- as.mbsts(y = y, components = c("trend", "seasonal"), seas.period = 7, s0.r = diag(3), s0.eps = diag(3), niter = 100, burn = 10)
prd <- predict(mbsts.1, steps.ahead = 20)
dim(prd$post.pred.1)
library(CausalMBSTS)
library(CausalMBSTS)
library(CausalMBSTS)
## Example 1 : local level + seasonal (d = 3)
y <- cbind(seq(0.5,200,by=0.5)*0.1 + rnorm(400),
seq(100.25,200,by=0.25)*0.05 + rnorm(400),
rnorm(400, 5,1))
mbsts.1 <- as.mbsts(y = y, components = c("trend", "seasonal"), seas.period = 7, s0.r = diag(3), s0.eps = diag(3), niter = 100, burn = 10)
## Example 2 : local level + seasonal + covariates (d = 2)
y <- cbind(rnorm(100), rnorm(100, 2, 3))
X <- cbind(rnorm(100, 0.5, 1) + 5, rnorm(100, 0.2, 2) - 2)
mbsts.2 <- as.mbsts(y = y, components = c("trend", "seasonal"), , seas.period = 7, X = X, s0.r = diag(2), s0.eps = diag(2), niter = 100, burn = 10)
prd <- predict(mbsts.1, steps.ahead = 20)
prd <- predict(mbsts.2, steps.ahead = 10, newdata = cbind(rnorm(10), rnorm(10)))
prd <- predict(mbsts.2, newdata = cbind(rnorm(10), rnorm(10)))
library(CausalMBSTS)
library(CausalMBSTS)
# Generating a panel of observations and a vector of dates
set.seed(1)
y <- cbind(seq(0.5,200,by=0.5)*0.1 + rnorm(400),
seq(100.25,200,by=0.25)*0.05 + rnorm(400),
seq(1,400,by=1)*(-0.01) + rnorm(400, 0, 0.5))
dates <- seq.Date(from = as.Date('2019-01-10'),by = "days", length.out = 400)
# Adding a fictional intervention and four covariates (they should be related to the outcome but unaffected by the intervention). To illustrate the functioning of Bayesian model selection, one covariate is assumed to be unrelated to y.
int.date <- as.Date('2019-11-05')
y.new <- y; y.new[dates >= int.date, ] <- y.new[dates >= int.date, ]*1.3
x1 <- y[,1]*0.5 + y[,2]*0.3 + y[,3]*0.1
x2 <- y[,2]*0.1 + rnorm(dim(y)[1],0,0.5)
x3 <- y[,3]*1.2 + rnorm(dim(y)[1],0,0.5)
x4 <- rnorm(dim(y)[1], 5, 10)
X <- cbind(x1, x2, x3, x4)
# Some plots
par(mfrow=c(1,3))
for(i in 1:dim(y.new)[2]){
plot(y.new[,i], x = dates, type='l', col='cadetblue', xlab='', ylab='', main= bquote(Y[.(i)]))
lines(y[,i], x = dates, col='orange')
}
par(mfrow=c(1,4))
for(i in 1:dim(X)[2]){
plot(X[,i], type='l', col = 'darkgreen', x = dates, xlab='', ylab='', main = bquote(x[.(i)]))
}
# Model definition
causal.1 <- CausalMBSTS(y.new, components = c("trend", "seasonal"), seas.period = 7, X = X, dates = dates, int.date = int.date, s0.r = 0.1*diag(3), s0.eps = 0.1*diag(3), niter = 100, burn = 10, horizon = c('2019-12-05','2020-02-13'))
causal.1$general.effect
library(CausalMBSTS)
## Example 1 (daily data, d = 3, local level + seasonal + covariates)
# Generating a panel of observations and a vector of dates
set.seed(1)
y <- cbind(seq(0.5,200,by=0.5)*0.1 + rnorm(400),
seq(100.25,200,by=0.25)*0.05 + rnorm(400),
seq(1,400,by=1)*(-0.01) + rnorm(400, 0, 0.5))
dates <- seq.Date(from = as.Date('2019-01-10'),by = "days", length.out = 400)
# Adding a fictional intervention and four covariates (they should be related to the outcome but unaffected by the intervention). To illustrate the functioning of Bayesian model selection, one covariate is assumed to be unrelated to y.
int.date <- as.Date('2019-11-05')
y.new <- y; y.new[dates >= int.date, ] <- y.new[dates >= int.date, ]*1.3
x1 <- y[,1]*0.5 + y[,2]*0.3 + y[,3]*0.1
x2 <- y[,2]*0.1 + rnorm(dim(y)[1],0,0.5)
x3 <- y[,3]*1.2 + rnorm(dim(y)[1],0,0.5)
x4 <- rnorm(dim(y)[1], 5, 10)
X <- cbind(x1, x2, x3, x4)
# Some plots
par(mfrow=c(1,3))
for(i in 1:dim(y.new)[2]){
plot(y.new[,i], x = dates, type='l', col='cadetblue', xlab='', ylab='', main= bquote(Y[.(i)]))
lines(y[,i], x = dates, col='orange')
}
par(mfrow=c(1,4))
for(i in 1:dim(X)[2]){
plot(X[,i], type='l', col = 'darkgreen', x = dates, xlab='', ylab='', main = bquote(x[.(i)]))
}
# Model definition
causal.1 <- CausalMBSTS(y.new, components = c("trend", "seasonal"), seas.period = 7, X = X, dates = dates, int.date = int.date, s0.r = 0.1*diag(3), s0.eps = 0.1*diag(3), niter = 100, burn = 10, horizon = c('2019-12-05','2020-02-13'))
causal.1$general.effect
library(CausalMBSTS)
print(causal.1)
